<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>陶语冰的博客</title>
    <link>https://shorterthandijkstra.github.io/</link>
    <description>Recent content on 陶语冰的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 May 2024 19:42:19 +0800</lastBuildDate><atom:link href="https://shorterthandijkstra.github.io/index.xml" rel="self" type="application/rss+xml" /><icon>https://shorterthandijkstra.github.io/img/icon.svg</icon>
    
    
    <item>
      <title>弗雷格也是纳粹吗？</title>
      <link>https://shorterthandijkstra.github.io/posts/frege/</link>
      <pubDate>Wed, 29 May 2024 19:42:19 +0800</pubDate>
      
      <guid>https://shorterthandijkstra.github.io/posts/frege/</guid>
      <description><![CDATA[<p><a href="https://www.aisixiang.com/data/106130.html">https://www.aisixiang.com/data/106130.html</a></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>读《会饮篇》</title>
      <link>https://shorterthandijkstra.github.io/posts/the-symposium/</link>
      <pubDate>Sun, 21 Apr 2024 17:41:43 +0800</pubDate>
      
      <guid>https://shorterthandijkstra.github.io/posts/the-symposium/</guid>
      <description><![CDATA[<p>(搁置）</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>读《论自由》</title>
      <link>https://shorterthandijkstra.github.io/posts/on-liberty/</link>
      <pubDate>Mon, 08 Apr 2024 19:18:42 +0800</pubDate>
      
      <guid>https://shorterthandijkstra.github.io/posts/on-liberty/</guid>
      <description><![CDATA[<p>(搁置）</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Forth: The programming language that writes itself</title>
      <link>https://shorterthandijkstra.github.io/posts/forth-reading/</link>
      <pubDate>Mon, 08 Jan 2024 18:56:42 +0800</pubDate>
      
      <guid>https://shorterthandijkstra.github.io/posts/forth-reading/</guid>
      <description><![CDATA[<p>这两天读一篇介绍Forth的<a href='https://ratfactor.com/forth/the_programming_language_that_writes_itself.html'>文章</a>，非常长，谨慎阅读。</p>
<p>讲了一些Forth的特性（Stack-based, Concatenative programming等），和创始人Chuck Moore发展Forth的历程，以及Forth的一些成功应用。</p>
<p>文章还列出了很多有趣的链接。</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>End of 2023</title>
      <link>https://shorterthandijkstra.github.io/posts/end-of-2023/</link>
      <pubDate>Mon, 01 Jan 2024 21:40:28 +0800</pubDate>
      
      <guid>https://shorterthandijkstra.github.io/posts/end-of-2023/</guid>
      <description><![CDATA[<p>如你所见，今天是2024年的第一天，我在夜晚写下这篇2023年的个人总结。</p>
<h1 id="学习">学习</h1>
<p>出于对PL的兴趣，看完了Friedman的<a href='https://eopl3.com/'>EOPL</a>，这书的内容大致是教人实现一个不标准的Ocaml。我把<a href='https://github.com/ShorterThanDijkstra/eopl3'>习题</a>做完了，写了非常多的解释器。这是我看的Friedman的第一本书，有时间把其他的作品也读读。</p>
<p>然后出于对编译器的兴趣，又读了一下Jeremy的<a href='https://mitpress.mit.edu/9780262047760/essentials-of-compilation/'> Essentials of Compilation </a>。因为不熟悉汇编，中间抽时间读完了王爽的《汇编语言》，不过读完后感觉这书过时了。和EOPL一样，EOC也是用Scheme作为教学语言，动态类型的语言重构起来很难受。我花了很多时间写GC和寄存器分配，最后写出来的编译器很多bug。虽然Scheme是我的编程语言初恋，但是我不会再用它写大型项目了。或许我应该直接读虎书。</p>
<p>对自己诚实是一个宝贵的品质。我本科的C语言学得很糟糕，对此我感到很焦虑。中间抽空把<a href='https://en.wikipedia.org/wiki/The_C_Programming_Language'>K&amp;R</a>读完了，没做习题，刷了几道<a href='https://github.com/ShorterThanDijkstra/codewars/tree/main/c'>codewars </a>。我操作系统也没学好，所以我把<a href='https://pages.cs.wisc.edu/~remzi/OSTEP/'>OSTEP</a>读了一遍。</p>
<p>其它编程语言方面，我看了一点Ocaml的内容，想实现一个<a  href='https://github.com/ShorterThanDijkstra/CeleryOcaml'>编程语言</a>，用来当作找一份相关工作的筹码，但是目前搁置了。等继续学数理逻辑和TAPL的时候再说吧。同时也学了一下Rust，看了一些材料，刷了一些<a href='https://github.com/ShorterThanDijkstra/codewars/tree/main/rust'>codewars</a>和<a href='https://github.com/ShorterThanDijkstra/codeforces/tree/main/rust'>codeforces</a>。</p>
<p>除此之外，我看了一些金融，区块链方面的材料，也在继续学英语。</p>
<p>看似学了很多东西，但是我其实可以做得更好。因为自制力不够，我浪费了很多时间。比如玩手机玩得很晚，第二天脑袋昏沉，无法学习。希望自己能慢慢改变这些不好的习惯。</p>
<p>我有一股深深的知识和技能焦虑，比起其他厉害的同龄人，我差太远了。我不嫉妒他们，但是需要努力向他们学习，这样才不会落得太远。当然，求知的第一推动力应该是兴趣和好奇。</p>
<h1 id="自由">自由</h1>
<p>我将分两个维度讨论这个问题：精神自由和财富自由。</p>
<p>首先讨论精神自由。庄子说：“岂唯形骸有聋盲哉？”我深感自己的心智受到了蒙蔽，被困在枷锁中。我浅浅分析了一下，导致我精神困境的因素主要有两个，第一个是错误的观念。</p>
<p>笛卡尔在《第一哲学沉思集》里的第一个沉思里这样写道：</p>
<blockquote>
<p>由于很久以来我就感觉到我自从幼年时期起就把一大堆错误的见解当作真实的接受了过来，而从那时以后我根据一些非常靠不住的原则建立起来的东西都不能不是十分可以、十分不可靠的，因此我认为，如果我想要在科学上建立起某种坚定可靠、经久不变的东西的话，我就非在我有生之日认真地把我历来信以为真的一切见解统统清除出去，再从根本上重新开始不可。</p>
</blockquote>
<p>在我成长的过程中，我也把一大堆错误的见解刻在自己的脑中，这给我的心灵造成了很大的痛苦。</p>
<p>第二个因素是我自制力很差，无法控制自己享乐的欲望：比如沉迷短视频这种垃圾快乐（我从来不刷抖音，但是我喜欢玩b站），比如想要在他人身上获得虚荣。哲学家警告我们，金钱和社会地位是不值得追求的，对精神自由有害，但是和大多数人一样，我发现对这些东西的追逐是个迷人的游戏。</p>
<p>我昨天读完了一本介绍<a href='https://book.douban.com/subject/27167270/'>斯多葛主义的书</a>，它上面给出的一些建议或者有助于获得精神上的<a href='https://en.wikipedia.org/wiki/Eudaimonia'>安宁</a>。</p>
<ul>
<li>想象自己可能会遭受悲惨境遇，这样当灾难来临时，痛苦会减轻一些，同时也会让我们更珍惜当下所拥有的。</li>
<li>将事情分为三个维度：我们不能控制的，比如天气；我们能够控制的，比如自己的价值观；我们能够在一定程度上控制的，比如赢得一场比赛。对于我们不能控制的事物，根本无需过多担心。对于我们能够控制的，我们应该细心把控。对于最后一种情况，我们要学会区分内在和外在的目标，将努力放在实现内在目标上。比如参加网球比赛，外在目标是赢得比赛，这是我们不能控制的。但是我们可以在平时努力训练，赛前好好休息，这是我们能够实现的内在目标。</li>
<li>为了获得未来的安宁，可以思考过去和现在，但是过去和现在是无法改变的，所以只能拥抱它们。</li>
<li>偶尔过一种清苦的生活，警惕享乐。这能锻炼我们的意志力和自控力，它们对践行一种人生哲学是至关重要的。</li>
<li>时常反省自己，审视自己的思想，审视自己的情感，审视自己的动因。</li>
</ul>
<p>我还读了一点《庄子》，但是刚开始。</p>
<p>接下来讨论财富自由。</p>
<p>哲学家告诫我们，财富是不值得追求的。人生短暂，我也认为把生命的主要精力放在追求财富上是愚蠢的。但是我认为财富有其价值。首先一点，如果有钱了，我就可以不做厌恶的工作，我可以把精力放在学习，写代码，阅读，旅游上。中国是一个福利很差的国家，财富能让我的家人过上更好的生活。</p>
<p>但是获得财富是很困难的，而且世界变得越来越不平等。认真打工的人很难买一栋房子，很多人投机取巧甚至贪赃枉法却能获取巨量的钱财。</p>
<p>我也看了一下北大教授的<a href='https://book.douban.com/subject/30296163/'>《金融经济学二十五讲》</a>，但是很困惑，精力又不够，后面就放弃了。</p>
<h1 id="工作">工作</h1>
<p>很多的工作是没有意义的，甚至是对社会有害的。我对现在的工作并不是很满意，希望自己以后能够做一些酷的工作，认识酷的人，即使赚不到钱也没关系。</p>
<h1 id="2024年要做什么">2024年要做什么</h1>
<ul>
<li>强健的体魄，健康的作息。</li>
<li>继续学习PLT，学习数理逻辑和类型论。</li>
<li>刷Project Euler。</li>
<li>践行斯多葛主义。</li>
<li>希望能够找一份编程语言相关的工作。</li>
<li>有时间学习一下乐理。</li>
</ul>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>memorized Fibonacci sequence</title>
      <link>https://shorterthandijkstra.github.io/posts/memorized-fibonacci/</link>
      <pubDate>Mon, 25 Dec 2023 21:40:50 +0800</pubDate>
      
      <guid>https://shorterthandijkstra.github.io/posts/memorized-fibonacci/</guid>
      <description><![CDATA[<p>今天在Codewars刷到<a href="https://www.codewars.com/kata/529adbf7533b761c560004e5/train/haskell">一题</a>，看到一个人的解答很巧妙。</p>
<p>众所周知，下面这段求斐波那契数列的代码很慢：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#50fa7b">fibonacci</span> <span style="color:#ff79c6">::</span> <span style="color:#8be9fd">Int</span> <span style="color:#ff79c6">-&gt;</span> <span style="color:#8be9fd">Integer</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">fibonacci</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">fibonacci</span> <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">fibonacci</span> n <span style="color:#ff79c6">=</span> fibonacci (n<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">+</span> fibonacci (n<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>)
</span></span></code></pre></div><p>我们可以转成迭代的方式或者使用记忆化搜索。</p>
<p>这是我从SICP的3.5节学到的，利用惰性求值算自然数数列：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>nat :: [Int]
</span></span><span style="display:flex;"><span>nat  = 0:map (+1) nat
</span></span></code></pre></div><p>ok，你已经学会了怎么求自然数数列，接下来算斐波那契数列吧：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#50fa7b">fib</span> <span style="color:#ff79c6">::</span> <span style="color:#8be9fd">Int</span> <span style="color:#ff79c6">-&gt;</span> [<span style="color:#8be9fd">Int</span>]
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">fib</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span><span style="color:#8be9fd">:</span><span style="color:#bd93f9">1</span><span style="color:#8be9fd">:</span>zipWith (<span style="color:#ff79c6">+</span>) fib (tail fib)
</span></span></code></pre></div><p>但是能不能在保留树形递归的同时进行记忆化搜索呢？</p>
<p>下面这段代码我觉得非常巧妙：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#50fa7b">fibonacci</span> <span style="color:#ff79c6">::</span> <span style="color:#8be9fd">Int</span> <span style="color:#ff79c6">-&gt;</span> <span style="color:#8be9fd">Integer</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">fibonacci</span> <span style="color:#ff79c6">=</span> (map fib&#39; [<span style="color:#bd93f9">0</span><span style="color:#ff79c6">..</span>] <span style="color:#ff79c6">!!</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">where</span>
</span></span><span style="display:flex;"><span>		fib&#39; <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>		fib&#39; <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>		fib&#39; n <span style="color:#ff79c6">=</span> fibonacci (n <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">+</span> fibonacci (n <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">2</span>)
</span></span></code></pre></div><p>以我对Haskell的浅薄理解，我证明不了上述代码有记忆化搜索的性质，希望有高手能教教我。</p>
<p>但是速度肯定是快多了，毕竟<a href="https://wiki.haskell.org/Memoization">Haskell Wiki</a>上是这样说的。</p>
<p>（ok，这个月的博客糊弄完了！）</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>测量TLB的容量和访问TLB的开销</title>
      <link>https://shorterthandijkstra.github.io/posts/tlb-measurement/</link>
      <pubDate>Tue, 21 Nov 2023 21:40:28 +0800</pubDate>
      
      <guid>https://shorterthandijkstra.github.io/posts/tlb-measurement/</guid>
      <description><![CDATA[<p>TLB的全称是translation lookaside buffer，不懂这个概念的人就不要看下去了，本文只讲讲怎么测量TLB的容量和访问TLB的开销。</p>
<p>先来讲基本思路。假设我们有一个横跨多页的大数组arr，页面大小是4096个字节，int大小为4个字节，那么每页就有1024个数组元素。第1次访问arr[0]，第1次访问arr[1024]，第1次访问arr[2048] &hellip;&hellip; 于是我们就依次访问了第1页，第2页，第3页&hellip;&hellip;</p>
<p>开一个横跨多页的数组，依次修改各个页里面的数组元素，访问的页面数量逐渐变多，直到超过了TLB的容量，访问数组元素就会变慢，这就是基本思路。</p>
<p>几个问题：</p>
<ol>
<li>如何知道操作系统的页面大小？</li>
<li>对于有多个CPU的计算机，为了得到更准确的数据，如何做到程序只在一个CPU上运行？</li>
</ol>
<p>Talk is cheap, show you my code：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">#define _GNU_SOURCE
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;fcntl.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;stdint.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;stdio.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;stdlib.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;sys/time.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;unistd.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;sched.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define MAX_NUM_PAGES 256
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define TRIALS 10000000
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">trials</span>(<span style="color:#8be9fd">int</span> jump, <span style="color:#8be9fd">int</span> num_pages, <span style="color:#8be9fd">int</span> arr[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> timeval start, end;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">gettimeofday</span>(<span style="color:#ff79c6">&amp;</span>start, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> TRIALS; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> num_pages <span style="color:#ff79c6">*</span> jump; i <span style="color:#ff79c6">+=</span> jump)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            arr[i] <span style="color:#ff79c6">+=</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">gettimeofday</span>(<span style="color:#ff79c6">&amp;</span>end, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">uint64_t</span> trial_time <span style="color:#ff79c6">=</span> (end.tv_sec <span style="color:#ff79c6">-</span> start.tv_sec) <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">1000000</span> 
</span></span><span style="display:flex;"><span>                          <span style="color:#ff79c6">+</span> end.tv_usec <span style="color:#ff79c6">-</span> start.tv_usec;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">double</span> one_trial_time <span style="color:#ff79c6">=</span> trial_time 
</span></span><span style="display:flex;"><span>                           <span style="color:#ff79c6">/</span> (<span style="color:#8be9fd">double</span>)(num_pages <span style="color:#ff79c6">*</span> TRIALS);
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">printf</span>(<span style="color:#f1fa8c">&#34;pages:%d, average time:%f</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, 
</span></span><span style="display:flex;"><span>            num_pages, one_trial_time);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>(<span style="color:#8be9fd">int</span> argc, <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">cpu_set_t</span> cpuset;
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">CPU_ZERO</span>(<span style="color:#ff79c6">&amp;</span>cpuset);
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">CPU_SET</span>(<span style="color:#bd93f9">0</span>, <span style="color:#ff79c6">&amp;</span>cpuset);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (<span style="color:#50fa7b">sched_setaffinity</span>(<span style="color:#bd93f9">0</span>, <span style="color:#ff79c6">sizeof</span>(<span style="color:#8be9fd">cpu_set_t</span>), <span style="color:#ff79c6">&amp;</span>cpuset))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">fprintf</span>(stderr, <span style="color:#f1fa8c">&#34;Error setting cpu affinity</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> page_size <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">getpagesize</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> jump <span style="color:#ff79c6">=</span> page_size <span style="color:#ff79c6">/</span> <span style="color:#ff79c6">sizeof</span>(<span style="color:#8be9fd">int</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>arr <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>)<span style="color:#50fa7b">calloc</span>(MAX_NUM_PAGES <span style="color:#ff79c6">*</span> jump, <span style="color:#ff79c6">sizeof</span>(<span style="color:#8be9fd">int</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> pages <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>; pages <span style="color:#ff79c6">&lt;</span> MAX_NUM_PAGES; pages<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">trials</span>(jump, pages, arr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不开任何优化，使用GCC编译运行，然后查看结果。在我的计算机上，访问页面数量在[1,10]这个区间时，访问一页所需的时间大约为3ns左右；当页面数量落在[11, 26]时，所需时间为6ns左右；继续增加页面数量，所需时间涨到10ns上下了。这说明系统存在二级TLB。我很懒，就不画折线图了。</p>
<p>如果你有什么想法，或者发现了本文的问题，欢迎给我发<a href="mailto:alyssaphacker@qq.com">邮件</a>。</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title></title>
      <link>https://shorterthandijkstra.github.io/thoughts/not_getting_enough_deep_sleep_may_increase_the_risk_of_developing_dementia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shorterthandijkstra.github.io/thoughts/not_getting_enough_deep_sleep_may_increase_the_risk_of_developing_dementia/</guid>
      <description><![CDATA[<h3 id="title">title</h3>
<p>Not getting enough deep sleep may increase the risk of developing dementia</p>
<h3 id="url">url</h3>
<h1 id="heading"></h1>
<p><a href="https://www.medicalnewstoday.com/articles/not-getting-enough-deep-sleep-may-increase-dementia-risk#Clarifying-the-link-between-sleep,-aging,-and-dementia-risk">https://www.medicalnewstoday.com/articles/not-getting-enough-deep-sleep-may-increase-dementia-risk#Clarifying-the-link-between-sleep,-aging,-and-dementia-risk</a></p>
<h3 id="vocabulary">vocabulary</h3>
<ul>
<li>
<p>dementia</p>
<p>an illness that affects the brain and memory, and makes you gradually lose the ability to think and behave normally</p>
</li>
<li>
<p>prevalence</p>
<p>existing very commonly or happening often</p>
</li>
<li>
<p>curative</p>
<p>able to or intended to cure illness</p>
</li>
<li>
<p>screen</p>
<p>a medical test to see whether someone has an illness</p>
</li>
<li>
<p>metabolism</p>
<p>all the chemical processes in your body, especially those that cause food to be used for energy and growth</p>
</li>
<li>
<p>replenish</p>
<p>to put new supplies into something, or to fill something again</p>
</li>
<li>
<p>sedation</p>
<p>the use of drugs to make someone calm or go to sleep</p>
</li>
</ul>
<h3 id="summary">summary</h3>
<h5 id="what-is-deep-sleep">what is deep sleep</h5>
<p>Sleep consists of four main cycles: three cycles of non-REM (rapid eye movement) sleep and one cycle of REM sleep.</p>
<ol>
<li><strong>Stage 1 (Non-REM)</strong>: Light sleep, where you drift in and out of consciousness. Muscle activity slows down, and you may experience sudden muscle contractions (hypnic jerks). Brain waves begin to slow down from their wakeful state.</li>
<li><strong>Stage 2 (Non-REM)</strong>: The onset of true sleep. Brain waves continue to slow down with occasional bursts of rapid waves known as sleep spindles. Body temperature decreases, and heart rate slows down.</li>
<li><strong>Stage 3 (Non-REM)</strong>: Deep sleep, also known as slow-wave sleep. This stage is characterized by very slow brain waves (delta waves). It&rsquo;s difficult to wake someone from deep sleep, and this stage is crucial for physical restoration, immune function, and memory consolidation.</li>
<li><strong>REM Sleep</strong>: Rapid Eye Movement sleep, where dreaming occurs. Brain activity increases to near waking levels, but the body remains paralyzed (except for eye movements and minor muscle twitches). Heart rate and breathing become irregular, and this stage is important for emotional processing and memory consolidation.</li>
</ol>
<h5 id="why-does-deep-sleep-affect-dementia">why does deep sleep affect dementia</h5>
<p>Deep sleep is closely linked to brain health, and its role in affecting dementia is multifaceted:</p>
<ol>
<li><strong>Memory Consolidation</strong>: Deep sleep is crucial for memory consolidation, where the brain processes and stores information gathered during wakefulness. This process helps in retaining memories and learning new information. Inadequate deep sleep can impair this function, leading to memory difficulties and cognitive decline, which are early signs of dementia.</li>
<li><strong>Brain Waste Clearance</strong>: During deep sleep, the glymphatic system becomes more active. This system clears waste products from the brain, including toxic proteins such as beta-amyloid. Beta-amyloid is known to accumulate in the brains of individuals with Alzheimer&rsquo;s disease, a common form of dementia. Proper deep sleep facilitates the efficient removal of these toxins, potentially reducing the risk of developing dementia.</li>
<li><strong>Brain Structure and Function</strong>: Deep sleep is essential for maintaining the integrity and health of brain cells and neural networks. It supports neuronal repair, growth, and synaptic plasticity, all of which are critical for optimal brain function. Disruptions in deep sleep can compromise these processes, contributing to neurodegenerative changes associated with dementia.</li>
<li><strong>Impact on Cognitive Function</strong>: Adequate deep sleep supports various cognitive functions, including attention, problem-solving, and decision-making. Chronic sleep deprivation or poor quality sleep can impair these functions, exacerbating cognitive decline and increasing the risk of dementia over time.</li>
</ol>
<h3 id="tips-for-better-sleep">tips for better sleep</h3>
<p>Things that can improve the quality of sleep: reducing stress before bedtime, taking a warm shower or bath, sleeping in a cooler room, avoiding screen time in the afternoon and evening, and using blue light filter.</p>
<p>Traditional sedatives like sleeping pills do not improve sleep quality or duration, including deep sleep. They may trick the brain into believing sleep was better than it was, but research shows they only marginally increase total sleep time by a few minutes per night.</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title></title>
      <link>https://shorterthandijkstra.github.io/thoughts/%E6%89%8B%E6%9C%BA%E5%A4%A7%E8%84%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shorterthandijkstra.github.io/thoughts/%E6%89%8B%E6%9C%BA%E5%A4%A7%E8%84%91/</guid>
      <description><![CDATA[<h1 id="进化的惯性">进化的惯性</h1>
<p>很多人有过这样的经历：在明明已经吃饱的情况下，面对美味的食物，还想继续吃下去，即使理性告诉自己，再吃下去对身体不好。人为什么会有这样的欲望？人类所有的欲望都和进化有关。在生产力不发达的时代，很多人要面临饥饿的威胁。看到树上的果子，有的人吃饱后就离开了，第二天饿了再来，树上已经没有了果子。而有的人吃饱后还想继续吃，他们无疑有更大的生存几率。人类从诞生到现在，有多少时间需要面对饥饿的挑战？我没有考证过，考虑到今天仍然有人营养不良，我猜测这段时间的比例很大。虽然现在很多国家都没有饥饿的问题了，但是因为人类的温饱时代太短，大脑还不能适应新的环境。人吃饱了还想吃，是因为在漫长的历史中，这样的人能更好地存活下来。即使现在人类已经进入不愁吃喝的时代，但是这段时间太短，我们还保留了这样的欲望。</p>
<p>进化是一条遥迢千里的河流，个人只是河流上的一滴水，个人无法克服食欲，也无法克服性欲，这是古希腊掌管进化的神给的设定。</p>
]]></description>
      
    </item>
    
    
    
    
    
    
    
    
  </channel>
</rss>
